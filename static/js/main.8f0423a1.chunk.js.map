{"version":3,"sources":["components/SideBar.js","components/Map.js","components/Header.js","App.js","serviceWorker.js","index.js"],"names":["SideBar","state","query","updateQuery","_this","setState","props","filter","_this2","this","react_default","a","createElement","BurgerMenu","id","className","type","placeholder","value","onChange","event","target","globMarkers","map","globMarker","index","key","onClick","window","google","maps","trigger","href","title","Component","Map","venues","globMarkersTwo","val","toLowerCase","includes","initMap","document","getElementById","center","lat","lng","zoom","infoWindow","InfoWindow","myVenue","marker","Marker","position","venue","location","name","animation","Animation","DROP","infoWindowContent","concat","address","infoWindowContentName","addListener","setContent","open","push","loadMap","url","getElementsByTagName","script","src","async","defer","parentNode","insertBefore","loadScript","getVenues","axios","get","URLSearchParams","client_id","client_secret","ll","section","v","then","response","data","groups","items","catch","error","console","log","components_SideBar","clickHandler","triggerClick","Header","App","components_Header","components_Map","Boolean","hostname","match","ReactDOM","render","src_App_0","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.8f0423a1.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport '../App.css';\r\nimport { slide as Menu } from 'react-burger-menu';\r\nimport MediaQuery from 'react-responsive';\r\n\r\nclass SideBar extends Component {\r\n\r\n  state = {\r\n    query: ''\r\n  }\r\n\r\n  updateQuery = (query) => {\r\n    this.setState({ query })\r\n    this.props.filter(query)\r\n  };\r\n\r\n\r\n  // populateSideBar = () => {\r\n  //   const getMenu = document.getElementById('menu');\r\n  //   this.props.venues.map(myVenue => {\r\n  //     const childElement = document.createElement('li');\r\n  //     childElement.innerHTML={myVenue.venue.name}\r\n  //     getMenu.appendChild(childElement)\r\n  //   })\r\n  // }\r\n\r\n  render(){\r\n    return (\r\n        <Menu id='menu'>\r\n          <input\r\n            className=\"search-input\"\r\n            type=\"text\"\r\n            placeholder=\"Search for the cool venue\"\r\n            value={this.state.query}\r\n            onChange={(event) => this.updateQuery(event.target.value)}\r\n          />\r\n          <ul>\r\n            {this.props.globMarkers && this.props.globMarkers.map((globMarker, index) => (\r\n                <li key={index} onClick={() => {window.google.maps.event.trigger(globMarker, 'click')}}><a href='#'>{globMarker.title}</a></li>\r\n            ))}\r\n          </ul>\r\n        </Menu>\r\n    )\r\n  };\r\n}\r\n\r\nexport default SideBar;\r\n","import React, { Component } from 'react';\r\nimport '../App.css';\r\nimport axios from 'axios';\r\nimport SideBar from './SideBar'\r\n\r\nclass Map extends Component {\r\n\r\n  state = {\r\n    venues: [],\r\n    globMarkers: [],\r\n    globMarkersTwo: []\r\n  }\r\n\r\n  componentDidMount(){\r\n    this.getVenues()\r\n  }\r\n\r\n/*\r\n  Filtering the results for SideBar\r\n*/\r\n\r\n  filter = (query) => {\r\n    this.setState({\r\n      globMarkers: this.state.globMarkersTwo.filter((val) => {\r\n        return val.title.toLowerCase().includes(query.toLowerCase())\r\n      })\r\n    })\r\n  }\r\n\r\n/*\r\n  Initializing a new map\r\n*/\r\n\r\n  initMap = () => {\r\n    const map = new window.google.maps.Map(document.getElementById('map'), {\r\n        center: {lat: 30.2672, lng: -97.7431},\r\n        zoom: 15\r\n      });\r\n\r\n    let globMarkers = []\r\n\r\n    /*\r\n      Creating an Info Window\r\n    */\r\n\r\n    let infoWindow = new window.google.maps.InfoWindow() // {content: infoWindowContent}\r\n\r\n    /*\r\n      Looping through the venues array to create a marker for each instance\r\n    */\r\n\r\n    this.state.venues.map(myVenue => { // <-- looping through state.venue to create a marker and an infoWindow for each instance\r\n      /*\r\n        Creating a marker\r\n      */\r\n\r\n      let marker = new window.google.maps.Marker({\r\n        position: {lat: myVenue.venue.location.lat , lng: myVenue.venue.location.lng},\r\n        map: map,\r\n        title: myVenue.venue.name,\r\n        animation: window.google.maps.Animation.DROP\r\n      })\r\n\r\n\r\n      let infoWindowContent = `${myVenue.venue.location.address}`\r\n      let infoWindowContentName = `${myVenue.venue.name}`\r\n\r\n      marker.addListener('click', () => {\r\n        infoWindow.setContent('<div>' + '<div class=\"infoContent\">' + infoWindowContent + '</div>' + infoWindowContentName + '</div>')\r\n        infoWindow.open(map, marker)\r\n      })\r\n\r\n      globMarkers.push(marker)\r\n\r\n\r\n    })\r\n    this.setState({globMarkers, globMarkersTwo: globMarkers})\r\n  }\r\n\r\n/*\r\n  Invoking our outer function to load a script inside React, so it has access to it\r\n*/\r\n\r\n  loadMap = () => {\r\n    loadScript('https://maps.googleapis.com/maps/api/js?key=AIzaSyACKfranXXLfxanE5a_jhjxF0nE_Qph-Mw&v=3&callback=initMap')\r\n    window.initMap = this.initMap\r\n  }\r\n\r\n/*\r\n  Getting our venues from the FourSquare Places API\r\n*/\r\n\r\n  getVenues = () => {\r\n    const endPoint = 'https://api.foursquare.com/v2/venues/explore?'\r\n    const parameters = { // <-- info to start working with axios\r\n      client_id: 'S44FOYPH1XTS3QWHCAGDHU2PAZOWTSQMVR5ALVHR1VF4AZ3Y',\r\n      client_secret: '1LT1GOD1E3Q25I5FGRW0UBOYVLLSTJWRTPSTIT32IWAEQRZM',\r\n      ll: '30.2672, -97.7431',\r\n      section: 'topPicks',\r\n      v: '20181207' // All foursquare API requests require a version parameter. This gives developers control over the time period in which to call their continuously updated API.\r\n      // radius: '10000'\r\n    }\r\n\r\n    axios.get(endPoint + new URLSearchParams(parameters))\r\n      .then(response => {\r\n        // console.log(response.data.response.groups[0].items)\r\n        this.setState(() => {\r\n          return{venues: response.data.response.groups[0].items}\r\n        }, this.loadMap()) // <-- callback which is being executed ONLY as soon as all the data is fetched\r\n      })\r\n      .catch(error => {\r\n        console.log(error)\r\n      })\r\n  }\r\n\r\n  render(){\r\n    return(\r\n      <section>\r\n        <SideBar\r\n          globMarkers={this.state.globMarkers}\r\n          clickHandler={this.triggerClick}\r\n          filter={this.filter}\r\n        />\r\n        <div id=\"page-wrap\">\r\n        </div>\r\n        <div id='map'>\r\n        </div>\r\n      </section>\r\n    )\r\n  }\r\n}\r\n\r\n\r\nfunction loadScript(url) {\r\n  let index = window.document.getElementsByTagName('script')[0];  //(the reference of the script tag) selects the 1st script tag in the document\r\n  let script = window.document.createElement('script'); //creating script tag, obv\r\n  script.src = url;\r\n  script.async = true;\r\n  script.defer = true\r\n  index.parentNode.insertBefore(script, index) //inserts our script before the very 1st one, to make ours 1st(to keep it at the very beginning of the scripts list)\r\n}\r\n\r\n\r\n\r\nexport default Map;\r\n","import React, { Component } from 'react';\r\nimport '../App.css'\r\n\r\nclass Header extends Component {\r\n  render(){\r\n    return(\r\n      <div>\r\n        <div className='header'>\r\n          Neighbourhood Map\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\nexport default Header;\r\n","import React, { Component } from 'react';\nimport './App.css';\nimport Map from './components/Map';\nimport Header from './components/Header'\n\n\nclass App extends Component {\n\n  render(){\n    return(\n      <main>\n        <Header />\n        <Map />\n      </main>\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}